{"version":3,"file":"static/webpack/static/development/pages/test/b.js.d9f639b5c9f79edc5ff0.hot-update.js","sources":["webpack:///./pages/index.js","webpack:///./pages/test/b.js"],"sourcesContent":["import Link from 'next/link'\nimport Router from 'next/router'\nimport { Button } from 'antd'\n\nexport default () => {\n    const events = [\n        'routeChangeStart',\n        'routeChangeComplete',\n        'routeChangeError',\n        'beforeHistoryChange',\n        'hashChangeStart',\n        'hashChangeComplete',\n    ]\n\n    function makeEvent(type) {\n        return (...args) => {\n            console.log(type, ...args)\n        }\n    }\n\n    events.forEach(event => {\n        Router.events.on(event, makeEvent(event))\n    })\n\n    function gotoTestB() {\n        Router.push({\n            pathname:'/test/b',\n            query:{\n                id:2\n            }\n        }, '/test/b/2')\n    }\n    return (\n       <>\n           <span>Index</span>\n           <a>Index A</a>\n       </>\n\n    )\n}\n","import React, {useState, useEffect, useReducer, useLayoutEffect, useContext} from 'react'\nimport MyContext from '../'\nimport {Button} from \"antd\";\n\nclass MyCount extends React.Component {\n    state = {\n        count: 0\n    }\n\n    componentDidMount() {\n        this.interval = setInterval(() => {\n            this.setState({ count: this.state.count + 1})\n        },1000)\n    }\n\n    componentWillUnmount() {\n        if(this.interval){\n            clearInterval(this.interval)\n        }\n    }\n\n    render() {\n        return (\n            <span>{this.state.count}</span>\n        )\n    }\n}\n\nfunction countReducer(state, action) {\n    switch (action.type){\n        case 'add':\n            return state + 1  // need change object itself, not just change attribute within object otherwise the component cannot detect the updates\n        case 'minus':\n            return state - 1\n        default:\n            return state\n    }\n}\n\nfunction MyCountFunc() {\n    // const [count, setCount] = useState(0) //Array Destructuring Assignment [a,b] = 0\n\n    const [count, dispatchCount] = useReducer(countReducer, 0)\n    const [name, setName] = useState('han')\n\n    // useEffect(() => {\n    //     const interval = setInterval(() => {\n    //         // setCount(count => count + 1)\n    //         dispatchCount({type: 'minus'})\n    //     },1000)\n    //\n    //     return () => clearInterval(interval)\n    // }, [])\n\n    //useEffect will work after dom loaded\n    useEffect(() => {\n        console.log('effect invoked')\n        return () => console.log('effect detected')\n    }, [count]) // the second param decide useEffect update or not.\n\n    //useLayoutEffect will work before dom loaded but it will affect the speed of web page loading\n    useLayoutEffect(() => {\n        console.log('Layout effect invoked')\n        return () => console.log('Layout effect detected')\n    },[count])\n\n    return (\n        <div>\n            <input vaule={name} onChange={((e) => e.target.value)} />\n            <button onClick={() => dispatchCount({ type:\"add\"})}>{count}</button>\n        </div>\n    )\n}\n\nexport default MyCountFunc\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AAGA;AACA;AACA;AAQA;AACA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAFA;AAMA;AACA;AAAA;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;AACA;AACA;AADA;AACA;;;;;;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AAGA;;;;AArBA;AACA;AAuBA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AANA;AAQA;AACA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;;;;A","sourceRoot":""}